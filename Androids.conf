///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file for emotion features <      //////////////////
/////////   Feature set of Interspeech 2009 Emotion Challenge        //////////////////
/////////   384 features                                             //////////////////
/////////                                                            //////////////////
/////////  * written 2009 by Florian Eyben *                         //////////////////
/////////                                                            //////////////////
///////// (c) 2009 by Florian Eyben, Martin Wöllmer, Björn Schuller  //////////////////
/////////     see the file COPYING for details                       //////////////////
///////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
;
; This section is always required in openSMILE configuration files
;   it configures the componentManager and gives a list of all components which are to be loaded
; The order in which the components are listed should match 
;   the order of the data flow for most efficient processing
;
///////////////////////////////////////////////////////////////////////////////////////
[componentInstances:cComponentManager]
 ; this line configures the default data memory:
instance[dataMemory].type=cDataMemory
instance[waveIn].type=cWaveSource
instance[fr1].type=cFramer
instance[pe2].type=cVectorPreemphasis
instance[w1].type=cWindower
instance[fft1].type=cTransformFFT
instance[fftmp1].type=cFFTmagphase
instance[mspec].type=cMelspec
instance[mfcc].type=cMfcc
instance[mzcr].type=cMZcr
instance[energy].type=cEnergy
instance[Int].type = cIntensity

instance[scale].type=cSpecScale
instance[shs].type=cPitchShs
instance[pitchSmooth].type=cPitchSmootherViterbi
instance[volmerge].type=cValbasedSelector
instance[pitchJitter].type=cPitchJitter
instance[spectral].type=cSpectral

instance[lld].type=cContourSmoother
instance[lld2].type=cContourSmoother
instance[lld3].type=cContourSmoother
instance[delta1].type=cDeltaRegression
instance[delta2].type=cDeltaRegression
instance[delta3].type=cDeltaRegression
instance[functL1].type=cFunctionals
instance[csvSink].type = cCsvSink

printLevelStats=0
nThreads=1



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////   component configuration  ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
; the following sections configure the components listed above
; a help on configuration parameters can be obtained with 
;  SMILExtract -H
; or
;  SMILExtract -H configTypeName (= componentTypeName)
/////////////////////////////////////////////////////////////////////////////////////////////

[waveIn:cWaveSource]
writer.dmLevel=wave
filename=\cm[inputfile(I){test.wav}:name of input file]
sampleRate = 44100
monoMixdown=1

[fr1:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames
;frameSize = 0.0250
frameSize=0.0250
frameStep = 0.010

[pe2:cVectorPreemphasis]
reader.dmLevel=frames
writer.dmLevel=framespe
k=0.97

[w1:cWindower]
reader.dmLevel=framespe
writer.dmLevel=winframe
winFunc = ham
gain = 1.0

// ---- LLD -----

[fft1:cTransformFFT]
reader.dmLevel=winframe
writer.dmLevel=fftc

[fftmp1:cFFTmagphase]
reader.dmLevel=fftc
writer.dmLevel=fftmag

[mspec:cMelspec]
reader.dmLevel=fftmag
writer.dmLevel=mspec1
htkcompatible = 1
usePower = 0
lofreq = 20
hifreq = 8000

[mfcc:cMfcc]
reader.dmLevel=mspec1
writer.dmLevel=mfcc1
firstMfcc = 1
lastMfcc =  12
htkcompatible = 1
writer.levelconf.nT = 200

[energy:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energy
nameAppend=energy
rms=1
log=0
writer.levelconf.nT = 200

[mzcr:cMZcr]
reader.dmLevel=frames
writer.dmLevel=mzcr
zcr=1
amax=0
mcr=0
maxmin=0
writer.levelconf.nT = 200

[Int:cIntensity]
reader.dmLevel=winframe
writer.dmLevel=intens
intensity = 1
loudness = 1
writer.levelconf.nT = 200

;;;;;;;;;;;;;;;;;;;; HPS pitch
[scale:cSpecScale]
reader.dmLevel=fftmag
writer.dmLevel=hps
// nameAppend =
copyInputName = 1
processArrayFields = 0
scale=octave
sourceScale = lin
// logScaleBase = 2
// logSourceScaleBase = 2
// firstNote = 55
interpMethod = spline
minF = 25
maxF = -1
nPointsTarget = 0
specSmooth = 1
specEnhance = 1
auditoryWeighting = 1 

[shs:cPitchShs]
reader.dmLevel=hps
writer.dmLevel=pitchShs
// nameAppend =
copyInputName = 1
processArrayFields = 0
maxPitch = 620
minPitch = 52
nCandidates = 6
scores = 1
voicing = 1
F0C1 = 0
voicingC1 = 0
F0raw = 1
voicingClip = 1
voicingCutoff = 0.700000
inputFieldSearch = Mag_octScale
octaveCorrection = 0
nHarmonics = 15
compressionFactor = 0.850000
greedyPeakAlgo = 1

writer.levelconf.growDyn = 0
writer.levelconf.isRb = 1
; This must be > than buffersize of viterbi smoother
writer.levelconf.nT = 200


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Pitch with Viterbi smoother
[pitchSmooth:cPitchSmootherViterbi]
reader.dmLevel=pitchShs
reader2.dmLevel=pitchShs
writer.dmLevel=pitchG60_viterbi
copyInputName = 1
bufferLength=30
F0final = 1
F0finalEnv = 0
voicingFinalClipped = 0
voicingFinalUnclipped = 1
F0raw = 0
voicingC1 = 0
voicingClip = 0
wTvv =10.0
wTvvd= 5.0
wTvuv=10.0
wThr = 4.0
wTuu = 0.0
wLocal=2.0
wRange=1.0

writer.levelconf.growDyn = 0
writer.levelconf.isRb = 1
writer.levelconf.nT = 200

// SHS/Viterbi pitch algo does strange things at very low amplitudes, so we filter these out 
[volmerge:cValbasedSelector]
reader.dmLevel = energy;pitchG60_viterbi
writer.dmLevel = pitchG60
idx=0
threshold=0.001
removeIdx=1
zeroVec=1
outputVal=0.0

writer.levelconf.growDyn = 0
writer.levelconf.isRb = 1
writer.levelconf.nT = 200

;;;;;;;;;;;;;;;;;;; VQ

[pitchJitter:cPitchJitter]
reader.dmLevel = wave
writer.dmLevel = jitterShimmer
// nameAppend =
copyInputName = 1
; is pitchF really necessary, or can we use pitchG60 ?
F0reader.dmLevel = pitchG60
F0field = F0final
searchRangeRel = 0.250000
jitterLocal = 1
jitterDDP = 1
jitterLocalEnv = 0
jitterDDPEnv = 0
shimmerLocal = 1
shimmerLocalEnv = 0
onlyVoiced = 0
logHNR = 1
inputMaxDelaySec = 2.0
;periodLengths = 0
;periodStarts = 0
useBrokenJitterThresh = 0

writer.levelconf.growDyn = 0
writer.levelconf.isRb = 1
writer.levelconf.nT = 200

;;;;;;;;;;;;;;; spectral
[spectral:cSpectral]
reader.dmLevel=fftmag
writer.dmLevel=spectral
bands[0]=250-650
bands[1]=1000-4000
rollOff[0] = 0.25
rollOff[1] = 0.50
rollOff[2] = 0.75
rollOff[3] = 0.90
flux=1
centroid=1
maxPos=0
minPos=0
entropy=1
variance=1
skewness=1
kurtosis=1
slope=1
sharpness = 1
tonality = 0
harmonicity = 1
flatness = 1
writer.levelconf.nT=200

/////////////////////////////////////////////////////////////////////////////////////////

[lld:cContourSmoother]
reader.dmLevel=energy;mfcc1;mzcr;pitchG60
// reader.dmLevel=energy;mfcc1;mzcr;pitchG60;intens
// reader.dmLevel=energy;mfcc1;mzcr;pitchG60
writer.dmLevel=lld
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
;processArrayFields=0
nameAppend = sma
copyInputName = 1

[lld2:cContourSmoother]
reader.dmLevel=intens;jitterShimmer
writer.dmLevel=lld2
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
;processArrayFields=0
nameAppend = sma
copyInputName = 1

[lld3:cContourSmoother]
reader.dmLevel=spectral
writer.dmLevel=lld3
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
;processArrayFields=0
nameAppend = sma
copyInputName = 1

/////////////////////////////////////////////////////////////////////////////////////////////

// ---- delta regression of LLD ----
[delta1:cDeltaRegression]
reader.dmLevel=lld
writer.dmLevel=lld_de
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
;processArrayFields=0
deltawin=2
blocksize=1

[delta2:cDeltaRegression]
reader.dmLevel=lld2
writer.dmLevel=lld_de2
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
;processArrayFields=0
deltawin=2
blocksize=1

[delta3:cDeltaRegression]
reader.dmLevel=lld3
writer.dmLevel=lld_de3
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
;processArrayFields=0
deltawin=2
blocksize=1

[functL1:cFunctionals]
reader.dmLevel=lld;lld_de;lld2;lld_de2;lld3;lld_de3
writer.dmLevel=func
 ; frameSize and frameStep = 0 => functionals over complete input
 ; (NOTE: buffersize of lld and lld_de levels must be large enough!!)
;frameSize=0.0250
frameSize=0.025
frameStep=0
functionalsEnabled=Extremes;Regression;Moments
Extremes.maxameandist=0
Extremes.minameandist=0
Extremes.amean=1
Regression.qregc1 = 0
Regression.qregc2 = 0
Regression.qregc3 = 0
Regression.qregerrA = 0
Regression.qregerrQ = 0
Regression.centroid = 0
Regression.linregerrA = 0
Moments.variance = 0

//////////////////////////////////////////////////////////////////////
///////////////////  data output configuration  //////////////////////
//////////////////////////////////////////////////////////////////////

[csvSink:cCsvSink]
reader.dmLevel = func
filename = \cm[outputfile(O){results.csv}:name of output CSV file for my features]
delimChar = ,
append = 0
timestamp = 0
number = 0
printHeader = 1






